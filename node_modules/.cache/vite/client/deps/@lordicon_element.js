import {
  __publicField
} from "./chunk-XNHBATJA.js";

// node_modules/@lordicon/element/dist/index.js
function e(e2) {
  return JSON.parse(JSON.stringify(e2));
}
function t(e2) {
  return null == e2;
}
function i(e2) {
  return null !== e2 && "object" == typeof e2;
}
function s(e2, t2, s2) {
  const r2 = Array.isArray(t2) ? t2 : t2.split(".");
  let n2 = e2;
  for (const e3 of r2) {
    if (!i(n2))
      return s2;
    if (!(e3 in n2))
      return s2;
    n2 = n2[e3];
  }
  return void 0 === n2 ? s2 : n2;
}
function r(e2, t2, i2) {
  let s2 = e2;
  const r2 = Array.isArray(t2) ? t2 : t2.split(".");
  for (let e3 = 0; e3 < r2.length; ++e3)
    e3 === r2.length - 1 ? s2[r2[e3]] = i2 : s2 = s2[r2[e3]];
}
var n = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", "indianred ": "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
function a(e2) {
  return e2.startsWith("#") ? 4 === e2.length ? `#${e2[1]}${e2[1]}${e2[2]}${e2[2]}${e2[3]}${e2[3]}` : e2 : n[e2.toLowerCase()] || "#000000";
}
function o(e2) {
  if (e2 && "string" == typeof e2)
    return e2.split(",").filter((e3) => e3).map((e3) => e3.split(":")).filter((e3) => 2 == e3.length).reduce((e3, t2) => (e3[t2[0].toLowerCase()] = a(t2[1]), e3), {});
}
function l(e2) {
  return "light" === e2 || 1 === e2 || "1" === e2 ? 1 : "regular" === e2 || 2 === e2 || "2" === e2 ? 2 : "bold" === e2 || 3 === e2 || "3" === e2 ? 3 : "number" == typeof e2 || "string" == typeof e2 ? +e2 : void 0;
}
function h(e2) {
  if ("string" == typeof e2)
    return e2;
}
function c(e2) {
  const t2 = e2.toString(16);
  return 1 == t2.length ? "0" + t2 : t2;
}
function d(e2) {
  return Math.round(e2 / 255 * 1e3) / 1e3;
}
function g(e2) {
  return Math.round(255 * e2);
}
function f(e2) {
  const { r: t2, g: i2, b: s2 } = function(e3) {
    let t3 = parseInt("#" != e3[0] ? e3 : e3.substring(1), 16);
    return { r: t3 >> 16 & 255, g: t3 >> 8 & 255, b: 255 & t3 };
  }(e2);
  return [d(t2), d(i2), d(s2)];
}
function u(e2) {
  return function(e3) {
    return "#" + c(e3.r) + c(e3.g) + c(e3.b);
  }({ r: g(e2[0]), g: g(e2[1]), b: g(e2[2]) });
}
function m(e2, { lottieInstance: t2 } = {}) {
  const i2 = [];
  return e2 && e2.layers ? (e2.layers.forEach((e3, s2) => {
    e3.nm && e3.ef && e3.ef.forEach((e4, r2) => {
      var _a, _b, _c;
      const n2 = (_c = (_b = (_a = e4 == null ? void 0 : e4.ef) == null ? void 0 : _a[0]) == null ? void 0 : _b.v) == null ? void 0 : _c.k;
      if (void 0 === n2)
        return;
      let a2, o2;
      if (a2 = t2 ? `renderer.elements.${s2}.effectsManager.effectElements.${r2}.effectElements.0.p.v` : `layers.${s2}.ef.${r2}.ef.0.v.k`, "ADBE Color Control" === e4.mn ? o2 = "color" : "ADBE Slider Control" === e4.mn ? o2 = "slider" : "ADBE Point Control" === e4.mn ? o2 = "point" : "ADBE Checkbox Control" === e4.mn ? o2 = "checkbox" : e4.mn.startsWith("Pseudo/") && (o2 = "feature"), !o2)
        return;
      const l2 = e4.nm.toLowerCase();
      i2.push({ name: l2, path: a2, value: n2, type: o2 });
    });
  }), i2) : i2;
}
function y(e2, t2) {
  for (const i2 of t2)
    r(e2, i2.path, i2.value);
}
function p(e2, t2, i2) {
  for (const s2 of t2)
    "color" === s2.type ? "object" == typeof i2 && "r" in i2 && "g" in i2 && "b" in i2 ? r(e2, s2.path, [d(i2.r), d(i2.g), d(i2.b)]) : Array.isArray(i2) ? r(e2, s2.path, i2) : "string" == typeof i2 && r(e2, s2.path, f(a(i2))) : "point" === s2.type ? "object" == typeof i2 && "x" in i2 && "y" in i2 ? (r(e2, s2.path + ".0", i2.x), r(e2, s2.path + ".1", i2.y)) : Array.isArray(i2) && (r(e2, s2.path + ".0", i2[0]), r(e2, s2.path + ".1", i2[1])) : r(e2, s2.path, i2);
}
var _ = "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var b = ["click", "mouseenter", "mouseleave"];
var v = "\n    :host {\n        position: relative;\n        display: inline-block;\n        width: 32px;\n        height: 32px;\n        transform: translate3d(0px, 0px, 0px);\n    }\n\n    :host(.current-color) svg path[fill] {\n        fill: currentColor;\n    }\n\n    :host(.current-color) svg path[stroke] {\n        stroke: currentColor;\n    }\n\n    svg {\n        position: absolute;\n        pointer-events: none;\n        display: block;\n        transform: unset!important;\n    }\n\n    ::slotted(*) {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n    .body.ready ::slotted(*) {\n        display: none;\n    }\n";
var E;
var k = ["colors", "src", "icon", "state", "trigger", "loading", "target", "stroke"];
var _I = class _I extends HTMLElement {
  constructor() {
    super(...arguments);
    __publicField(this, "_root");
    __publicField(this, "_isConnected", false);
    __publicField(this, "_isReady", false);
    __publicField(this, "_assignedIconData");
    __publicField(this, "_loadedIconData");
    __publicField(this, "_triggerInstance");
    __publicField(this, "_playerInstance");
    __publicField(this, "delayedLoading", null);
  }
  static get version() {
    return "1.4.2";
  }
  static get observedAttributes() {
    return k;
  }
  static setIconLoader(e2) {
    _I._iconLoader = e2;
  }
  static setPlayerFactory(e2) {
    _I._playerFactory = e2;
  }
  static defineTrigger(e2, t2) {
    _I._definedTriggers.set(e2, t2);
  }
  attributeChangedCallback(e2, t2, i2) {
    this[`${e2}Changed`].call(this);
  }
  connectedCallback() {
    if (this._root || this.createElements(), "lazy" === this.loading) {
      let e2;
      this.delayedLoading = (t2) => {
        e2.unobserve(this), e2 = void 0, this.delayedLoading = null, t2 || this.createPlayer();
      };
      e2 = new IntersectionObserver((t2, i2) => {
        t2.forEach((t3) => {
          t3.isIntersecting && e2 && this.delayedLoading && this.delayedLoading();
        });
      }), e2.observe(this);
    } else if ("interaction" === this.loading) {
      let e2;
      this.delayedLoading = (s2) => {
        for (const e3 of b)
          (t2 || this).removeEventListener(e3, i2);
        this.delayedLoading = null, s2 || this.createPlayer().then(() => {
          (t2 || this).dispatchEvent(new Event(e2));
        });
      };
      const t2 = this.target ? this.closest(this.target) : null;
      let i2 = (t3) => {
        const i3 = t3 == null ? void 0 : t3.type;
        e2 ? e2 = i3 : (e2 = i3, this.delayedLoading && this.delayedLoading());
      };
      i2 = i2.bind(this);
      for (const e3 of b)
        (t2 || this).addEventListener(e3, i2);
    } else
      this.createPlayer();
    this._isConnected = true;
  }
  disconnectedCallback() {
    this.delayedLoading && this.delayedLoading(true), this.destroyPlayer(), this._isConnected = false;
  }
  createElements() {
    if (this._root = this.attachShadow({ mode: "open" }), _)
      E || (E = new CSSStyleSheet(), E.replaceSync(v)), this._root.adoptedStyleSheets = [E];
    else {
      const e3 = document.createElement("style");
      e3.innerHTML = v, this._root.appendChild(e3);
    }
    const e2 = document.createElement("div");
    e2.classList.add("body"), this._root.appendChild(e2);
    const t2 = document.createElement("slot");
    e2.appendChild(t2);
  }
  async createPlayer() {
    if (!_I._playerFactory)
      throw new Error("Missing player loader!");
    if (this.delayedLoading)
      return;
    const e2 = await this.loadIconData();
    if (!e2)
      return;
    this._playerInstance = _I._playerFactory(this.animationContainer, e2, { state: h(this.state), stroke: l(this.stroke), colors: o(this.colors), scale: parseFloat("" + this.getAttribute("scale") || ""), axisX: parseFloat("" + this.getAttribute("axis-x") || ""), axisY: parseFloat("" + this.getAttribute("axis-y") || "") });
    const t2 = Object.entries(this._playerInstance.colors || {});
    if (t2.length) {
      let e3 = "";
      for (const [i3, s2] of t2)
        e3 += `
                    :host(:not(.current-color)) svg path[fill].${i3} {
                        fill: var(--lord-icon-${i3}, var(--lord-icon-${i3}-base, #000));
                    }
        
                    :host(:not(.current-color)) svg path[stroke].${i3} {
                        stroke: var(--lord-icon-${i3}, var(--lord-icon-${i3}-base, #000));
                    }
                `;
      const i2 = document.createElement("style");
      i2.innerHTML = e3, this.animationContainer.appendChild(i2);
    }
    this._playerInstance.connect(), this._playerInstance.addEventListener("ready", () => {
      this._triggerInstance && this._triggerInstance.onReady && this._triggerInstance.onReady();
    }), this._playerInstance.addEventListener("refresh", () => {
      this.refresh(), this._triggerInstance && this._triggerInstance.onRefresh && this._triggerInstance.onRefresh();
    }), this._playerInstance.addEventListener("complete", () => {
      this._triggerInstance && this._triggerInstance.onComplete && this._triggerInstance.onComplete();
    }), this._playerInstance.addEventListener("frame", () => {
      this._triggerInstance && this._triggerInstance.onFrame && this._triggerInstance.onFrame();
    }), this.refresh(), this.triggerChanged(), await new Promise((e3, t3) => {
      this._playerInstance.isReady ? e3() : this._playerInstance.addEventListener("ready", e3);
    }), this._isReady = true, this.dispatchEvent(new CustomEvent("ready"));
  }
  destroyPlayer() {
    this._isReady = false, this._loadedIconData = void 0, this._triggerInstance && (this._triggerInstance.onDisconnected && this._triggerInstance.onDisconnected(), this._triggerInstance = void 0), this._playerInstance && (this._playerInstance.disconnect(), this._playerInstance = void 0);
  }
  async loadIconData() {
    let e2 = this.iconData;
    if (!e2) {
      if (this.icon && _I._iconLoader)
        this._loadedIconData = e2 = await _I._iconLoader(this.icon);
      else if (this.src) {
        const t2 = await fetch(this.src);
        this._loadedIconData = e2 = await t2.json();
      }
    }
    return e2;
  }
  refresh() {
    this.movePaletteToCssVariables();
  }
  movePaletteToCssVariables() {
    for (const [e2, t2] of Object.entries(this._playerInstance.colors || {}))
      t2 ? this.animationContainer.style.setProperty(`--lord-icon-${e2}-base`, t2) : this.animationContainer.style.removeProperty(`--lord-icon-${e2}-base`);
  }
  targetChanged() {
    this.triggerChanged();
  }
  loadingChanged() {
  }
  triggerChanged() {
    var _a;
    if (this._triggerInstance && (this._triggerInstance.onDisconnected && this._triggerInstance.onDisconnected(), this._triggerInstance = void 0, (_a = this._playerInstance) == null ? void 0 : _a.pause()), !this.trigger || !this._playerInstance)
      return;
    const e2 = _I._definedTriggers.get(this.trigger);
    if (!e2)
      throw new Error("Can't use unregistered trigger!");
    const t2 = this.target ? this.closest(this.target) : null;
    this._triggerInstance = new e2(this._playerInstance, this, t2 || this), this._triggerInstance.onConnected && this._triggerInstance.onConnected(), this._playerInstance.isReady && this._triggerInstance.onReady && this._triggerInstance.onReady();
  }
  colorsChanged() {
    this._playerInstance && (this._playerInstance.colors = o(this.colors) || null);
  }
  strokeChanged() {
    this._playerInstance && (this._playerInstance.stroke = l(this.stroke) || null);
  }
  stateChanged() {
    this._playerInstance && (this._playerInstance.state = this.state);
  }
  iconChanged() {
    this._isConnected && (this.destroyPlayer(), this.createPlayer());
  }
  srcChanged() {
    this._isConnected && (this.destroyPlayer(), this.createPlayer());
  }
  set icon(e2) {
    if (e2 && i(e2))
      this._assignedIconData !== e2 && (this._assignedIconData = e2, this.hasAttribute("icon") ? this.removeAttribute("icon") : this.iconChanged());
    else {
      const t2 = this._assignedIconData;
      this._assignedIconData = void 0, e2 && "string" == typeof e2 ? this.setAttribute("icon", e2) : (this.removeAttribute("icon"), t2 && this.iconChanged());
    }
  }
  get icon() {
    return this._assignedIconData || this.getAttribute("icon");
  }
  set src(e2) {
    e2 ? this.setAttribute("src", e2) : this.removeAttribute("src");
  }
  get src() {
    return this.getAttribute("src");
  }
  set state(e2) {
    e2 ? this.setAttribute("state", e2) : this.removeAttribute("state");
  }
  get state() {
    return this.getAttribute("state");
  }
  set colors(e2) {
    e2 ? this.setAttribute("colors", e2) : this.removeAttribute("colors");
  }
  get colors() {
    return this.getAttribute("colors");
  }
  set trigger(e2) {
    e2 ? this.setAttribute("trigger", e2) : this.removeAttribute("trigger");
  }
  get trigger() {
    return this.getAttribute("trigger");
  }
  set loading(e2) {
    e2 ? this.setAttribute("loading", e2) : this.removeAttribute("loading");
  }
  get loading() {
    if (this.getAttribute("loading")) {
      const e2 = this.getAttribute("loading").toLowerCase();
      if ("lazy" === e2)
        return "lazy";
      if ("interaction" === e2)
        return "interaction";
    }
    return null;
  }
  set target(e2) {
    e2 ? this.setAttribute("target", e2) : this.removeAttribute("target");
  }
  get target() {
    return this.getAttribute("target");
  }
  set stroke(e2) {
    e2 ? this.setAttribute("stroke", e2) : this.removeAttribute("stroke");
  }
  get stroke() {
    return this.hasAttribute("stroke") ? this.getAttribute("stroke") : null;
  }
  get isReady() {
    return this._isReady;
  }
  get playerInstance() {
    return this._playerInstance;
  }
  get triggerInstance() {
    return this._triggerInstance;
  }
  get animationContainer() {
    return this._root.lastElementChild;
  }
  get iconData() {
    return this._assignedIconData || this._loadedIconData;
  }
};
__publicField(_I, "_iconLoader");
__publicField(_I, "_playerFactory");
__publicField(_I, "_definedTriggers", /* @__PURE__ */ new Map());
var I = _I;
var C = { renderer: "svg", loop: false, autoplay: false, rendererSettings: { preserveAspectRatio: "xMidYMid meet", progressiveLoad: true, hideOnTransparent: true } };
function w() {
  return new Proxy(this, { set: (e2, t2, i2, s2) => ("string" == typeof t2 && (i2 ? p(this.lottie, this.rawProperties.filter((e3) => "color" === e3.type && e3.name === t2), i2) : y(this.lottie, this.rawProperties.filter((e3) => "color" === e3.type && e3.name === t2)), e2.refresh()), true), get: (e2, t2, i2) => {
    for (const i3 of e2.rawProperties)
      if ("color" == i3.type && "string" == typeof t2 && t2 == i3.name) {
        const e3 = s(this.lottie, i3.path);
        if (e3)
          return u(e3);
      }
  }, deleteProperty: (e2, t2) => ("string" == typeof t2 && (y(this.lottie, this.rawProperties.filter((e3) => "color" === e3.type && e3.name === t2)), e2.refresh()), true), ownKeys: (e2) => e2.rawProperties.filter((e3) => "color" == e3.type).map((e3) => e3.name), has: (e2, t2) => {
    for (const i2 of e2.rawProperties)
      if ("color" == i2.type && "string" == typeof t2 && t2 == i2.name)
        return true;
    return false;
  }, getOwnPropertyDescriptor: (e2) => ({ enumerable: true, configurable: true }) });
}
var L = class {
  constructor(i2, s2, n2, a2, o2) {
    __publicField(this, "_animationLoader");
    __publicField(this, "_container");
    __publicField(this, "_iconData");
    __publicField(this, "_initial");
    __publicField(this, "_options");
    __publicField(this, "_lottie");
    __publicField(this, "_isReady", false);
    __publicField(this, "_colorsProxy");
    __publicField(this, "_direction", 1);
    __publicField(this, "_speed", 1);
    __publicField(this, "_rawProperties");
    __publicField(this, "_eventCallbacks", {});
    __publicField(this, "_state");
    __publicField(this, "_states");
    if (this._animationLoader = i2, this._container = s2, this._iconData = n2, this._initial = a2 || {}, this._options = o2 || C, this._states = (n2.markers || []).map((e2) => {
      const [i3, s3] = e2.cm.split(":"), r2 = { time: e2.tm, duration: e2.dr, name: s3 || i3, default: !(!s3 || !i3.includes("default")) };
      return (r2.name === this._initial.state || r2.default && t(this._initial.state)) && (this._state = r2), r2;
    }).filter((e2) => e2.duration > 0), this._states.length && this._initial.stroke && ![1, 2, 3, "light", "regular", "bold"].includes(this._initial.stroke) && delete this._initial.stroke, !this._states.length) {
      this._iconData = e(this._iconData);
      const t2 = m(this._iconData, { lottieInstance: false });
      if (t2 && this._initial.state) {
        const e2 = `state-${this._initial.state.toLowerCase()}`;
        p(this._iconData, t2.filter((e3) => e3.name.startsWith("state-")), 0), p(this._iconData, t2.filter((t3) => t3.name === e2), 1);
      }
      if (t2 && this._initial.stroke) {
        const e2 = t2.filter((e3) => "stroke" === e3.name)[0];
        if (e2) {
          const t3 = e2.value / 50, i3 = this._initial.stroke * t3;
          r(this._iconData, e2.path, i3);
        }
      }
      if (t2 && this._initial.scale) {
        const e2 = t2.filter((e3) => "scale" === e3.name)[0];
        if (e2) {
          const t3 = e2.value / 50, i3 = this._initial.scale * t3;
          r(this._iconData, e2.path, i3);
        }
      }
      if (t2 && this._initial.axisX && this._initial.axisY) {
        const e2 = t2.filter((e3) => "axis" === e3.name)[0];
        if (e2) {
          const t3 = (e2.value[0] + e2.value[1]) / 2 / 50;
          r(this._iconData, e2.path + ".0", this._initial.axisX * t3), r(this._iconData, e2.path + ".1", this._initial.axisY * t3);
        }
      }
    }
  }
  connect() {
    if (this._lottie)
      throw new Error("Already connected player!");
    const t2 = {}, i2 = {};
    if (this._state && (i2.initialSegment = [this._state.time, this._state.time + this._state.duration + 1]), this._states.length) {
      const e2 = this._states[0], i3 = this._states[this._states.length - 1];
      t2.ip = e2.time, t2.op = i3.time + i3.duration + 1;
    }
    this._lottie = this._animationLoader({ ...this._options, ...i2, container: this._container, animationData: Object.assign(e(this._iconData), t2) }), this._initial.colors && (this.colors = this._initial.colors), this._initial.stroke && (this.stroke = this._initial.stroke), this._lottie.addEventListener("complete", (e2) => {
      this.triggerEvent("complete");
    }), this._lottie.addEventListener("loopComplete", () => {
      this.triggerEvent("complete");
    }), this._lottie.addEventListener("enterFrame", (e2) => {
      this.triggerEvent("frame");
    }), this._lottie.isLoaded ? (this._container.classList.add("ready"), this._isReady = true, this.triggerEvent("ready")) : this._lottie.addEventListener("config_ready", () => {
      this._container.classList.add("ready"), this._isReady = true, this.triggerEvent("ready");
    });
  }
  disconnect() {
    if (!this._lottie)
      throw new Error("Not connected player!");
    this._isReady = false, this._lottie.destroy(), this._lottie = void 0, this._colorsProxy = void 0, this._rawProperties = void 0, this._container.classList.remove("ready");
  }
  addEventListener(e2, t2) {
    return this._eventCallbacks[e2] || (this._eventCallbacks[e2] = []), this._eventCallbacks[e2].push(t2), () => {
      this.removeEventListener(e2, t2);
    };
  }
  removeEventListener(e2, t2) {
    if (t2) {
      if (this._eventCallbacks[e2]) {
        let i2 = 0, s2 = this._eventCallbacks[e2].length;
        for (; i2 < s2; )
          this._eventCallbacks[e2][i2] === t2 && (this._eventCallbacks[e2].splice(i2, 1), i2 -= 1, s2 -= 1), i2 += 1;
        this._eventCallbacks[e2].length || (this._eventCallbacks[e2] = null);
      }
    } else
      this._eventCallbacks[e2] = null;
  }
  triggerEvent(e2, t2) {
    if (this._eventCallbacks[e2]) {
      const i2 = this._eventCallbacks[e2];
      for (let e3 = 0; e3 < i2.length; e3 += 1)
        i2[e3](t2);
    }
  }
  refresh() {
    var _a;
    (_a = this._lottie) == null ? void 0 : _a.renderer.renderFrame(null), this.triggerEvent("refresh");
  }
  play() {
    this._lottie.setDirection(this._direction), this._lottie.play();
  }
  playFromBeginning() {
    this._lottie.setDirection(1), this._state ? this._lottie.playSegments([this._state.time, this._state.time + this._state.duration + 1], true) : this._lottie.goToAndPlay(0);
  }
  pause() {
    this._lottie.pause();
  }
  stop() {
    this._lottie.stop();
  }
  goToFrame(e2) {
    this._lottie.goToAndStop(e2, true);
  }
  goToFirstFrame() {
    this.goToFrame(0);
  }
  goToLastFrame() {
    this.goToFrame(Math.max(0, this.frames));
  }
  set properties(e2) {
    this.colors = e2.colors || null, this.stroke = e2.stroke || null, this.state = e2.state || null;
  }
  get properties() {
    const e2 = {};
    return this.rawProperties.filter((e3) => "color" === e3.type).length && (e2.colors = { ...this.colors }), this.rawProperties.filter((e3) => "stroke" === e3.name || "stroke-layers" === e3.name).length && (e2.stroke = this.stroke), this._states.length && (e2.state = this.state), e2;
  }
  set colors(e2) {
    if (y(this._lottie, this.rawProperties.filter((e3) => "color" === e3.type)), e2)
      for (const [t2, i2] of Object.entries(e2))
        p(this._lottie, this.rawProperties.filter((e3) => "color" === e3.type && e3.name === t2), i2);
    this.refresh();
  }
  get colors() {
    return this._colorsProxy || (this._colorsProxy = w.call(this)), this._colorsProxy;
  }
  set stroke(e2) {
    y(this._lottie, this.rawProperties.filter((e3) => "stroke" === e3.name || "stroke-layers" === e3.name));
    const t2 = l(e2);
    t2 && p(this._lottie, this.rawProperties.filter((e3) => "stroke" === e3.name || "stroke-layers" === e3.name), t2), this.refresh();
  }
  get stroke() {
    const e2 = this.rawProperties.filter((e3) => "stroke" === e3.name || "stroke-layers" === e3.name)[0];
    if (e2) {
      return l(+s(this._lottie, e2.path)) || null;
    }
    return null;
  }
  set state(e2) {
    var _a;
    if (e2 === this.state)
      return;
    const i2 = this.isPlaying;
    this._state = void 0, t(e2) ? this._state = this._states.filter((e3) => e3.default)[0] : e2 && (this._state = this._states.filter((t2) => t2.name === e2)[0]), this._state ? (_a = this._lottie) == null ? void 0 : _a.setSegment(this._state.time, this._state.time + this._state.duration + 1) : this._lottie.resetSegments(true), this.goToFirstFrame(), i2 && (this.pause(), this.play());
  }
  get state() {
    return this._state ? this._state.name : "";
  }
  set speed(e2) {
    var _a;
    this._speed = e2, (_a = this._lottie) == null ? void 0 : _a.setSpeed(e2);
  }
  get speed() {
    return this._speed;
  }
  set direction(e2) {
    this._direction = e2, this._lottie.setDirection(e2);
  }
  get direction() {
    return this._direction;
  }
  set loop(e2) {
    this._lottie.loop = e2;
  }
  get loop() {
    return !!this._lottie.loop;
  }
  set frame(e2) {
    this.goToFrame(Math.max(0, Math.min(this.frames, e2)));
  }
  get frame() {
    return this._lottie.currentFrame;
  }
  get states() {
    return this._states;
  }
  get isPlaying() {
    return !this._lottie.isPaused;
  }
  get isReady() {
    return this._isReady;
  }
  get frames() {
    return this._lottie.getDuration(true) - 1;
  }
  get duration() {
    return this._lottie.getDuration(false);
  }
  get lottie() {
    return this._lottie;
  }
  get rawProperties() {
    return this._rawProperties || (this._rawProperties = m(this._iconData, { lottieInstance: true }), !this._states.length && this._rawProperties && (this._rawProperties = this._rawProperties.filter((e2) => "scale" !== e2.name && "axis" !== e2.name && "stroke" !== e2.name && !e2.name.startsWith("state-")))), this._rawProperties || [];
  }
};
var D = class {
  constructor(e2, t2, i2) {
    __publicField(this, "player");
    __publicField(this, "element");
    __publicField(this, "targetElement");
    this.player = e2, this.element = t2, this.targetElement = i2, this.onHover = this.onHover.bind(this);
  }
  onConnected() {
    this.targetElement.addEventListener("mouseenter", this.onHover);
  }
  onDisconnected() {
    this.targetElement.removeEventListener("mouseenter", this.onHover), this.player.direction = 1;
  }
  onComplete() {
    this.player.direction = -1, this.player.play();
  }
  onHover() {
    this.player.direction = 1, this.player.play();
  }
};
var P = [{ name: "mousedown" }, { name: "touchstart", options: { passive: true } }];
var T = class {
  constructor(e2, t2, i2) {
    __publicField(this, "player");
    __publicField(this, "element");
    __publicField(this, "targetElement");
    this.player = e2, this.element = t2, this.targetElement = i2, this.onClick = this.onClick.bind(this);
  }
  onConnected() {
    for (const e2 of P)
      this.targetElement.addEventListener(e2.name, this.onClick, e2.options);
  }
  onDisconnected() {
    for (const e2 of P)
      this.targetElement.removeEventListener(e2.name, this.onClick);
  }
  onClick() {
    this.player.isPlaying || this.player.playFromBeginning();
  }
};
var A = class {
  constructor(e2, t2, i2) {
    __publicField(this, "player");
    __publicField(this, "element");
    __publicField(this, "targetElement");
    this.player = e2, this.element = t2, this.targetElement = i2, this.onHover = this.onHover.bind(this);
  }
  onConnected() {
    this.targetElement.addEventListener("mouseenter", this.onHover);
  }
  onDisconnected() {
    this.targetElement.removeEventListener("mouseenter", this.onHover);
  }
  onHover() {
    this.player.isPlaying || this.player.playFromBeginning();
  }
};
var F = class {
  constructor(e2, t2, i2) {
    __publicField(this, "player");
    __publicField(this, "element");
    __publicField(this, "targetElement");
    __publicField(this, "playTimeout", null);
    __publicField(this, "played", false);
    __publicField(this, "intersectionObserver");
    this.player = e2, this.element = t2, this.targetElement = i2;
  }
  onConnected() {
    if (this.loading)
      this.play();
    else {
      const e2 = (e3, t2) => {
        e3.forEach((e4) => {
          e4.isIntersecting && (this.play(), this.resetIntersectionObserver());
        });
      };
      this.intersectionObserver = new IntersectionObserver(e2), this.intersectionObserver.observe(this.element);
    }
  }
  onDisconnected() {
    this.played = false, this.resetIntersectionObserver(), this.resetPlayDelayTimer();
  }
  play() {
    this.played || (this.played = true, this.resetPlayDelayTimer(), this.delay > 0 ? this.playTimeout = setTimeout(() => {
      this.player.playFromBeginning();
    }, this.delay) : this.player.playFromBeginning());
  }
  resetIntersectionObserver() {
    this.intersectionObserver && (this.intersectionObserver.unobserve(this.element), this.intersectionObserver = void 0);
  }
  resetPlayDelayTimer() {
    this.playTimeout && (clearTimeout(this.playTimeout), this.playTimeout = null);
  }
  get delay() {
    const e2 = this.element.hasAttribute("delay") ? +(this.element.getAttribute("delay") || 0) : 0;
    return Math.max(e2, 0);
  }
  get loading() {
    return this.element.hasAttribute("loading");
  }
};
var x = class {
  constructor(e2, t2, i2) {
    __publicField(this, "player");
    __publicField(this, "element");
    __publicField(this, "targetElement");
    __publicField(this, "playTimeout", null);
    this.player = e2, this.element = t2, this.targetElement = i2;
  }
  onReady() {
    this.play();
  }
  onComplete() {
    this.play();
  }
  onDisconnected() {
    this.resetPlayDelayTimer();
  }
  play() {
    this.resetPlayDelayTimer(), this.delay > 0 ? this.playTimeout = setTimeout(() => {
      this.player.playFromBeginning();
    }, this.delay) : this.player.playFromBeginning();
  }
  resetPlayDelayTimer() {
    this.playTimeout && (clearTimeout(this.playTimeout), this.playTimeout = null);
  }
  get delay() {
    const e2 = this.element.hasAttribute("delay") ? +(this.element.getAttribute("delay") || 0) : 0;
    return Math.max(e2, 0);
  }
};
var M = class {
  constructor(e2, t2, i2) {
    __publicField(this, "player");
    __publicField(this, "element");
    __publicField(this, "targetElement");
    __publicField(this, "playTimeout", null);
    __publicField(this, "mouseIn", false);
    this.player = e2, this.element = t2, this.targetElement = i2, this.onMouseEnter = this.onMouseEnter.bind(this), this.onMouseLeave = this.onMouseLeave.bind(this);
  }
  onConnected() {
    this.targetElement.addEventListener("mouseenter", this.onMouseEnter), this.targetElement.addEventListener("mouseleave", this.onMouseLeave);
  }
  onDisconnected() {
    this.targetElement.removeEventListener("mouseenter", this.onMouseEnter), this.targetElement.removeEventListener("mouseleave", this.onMouseLeave), this.resetPlayDelayTimer();
  }
  onMouseEnter() {
    this.mouseIn = true, this.player.isPlaying || this.play();
  }
  onMouseLeave() {
    this.mouseIn = false, this.resetPlayDelayTimer();
  }
  onComplete() {
    this.play();
  }
  play() {
    this.resetPlayDelayTimer(), this.mouseIn && (this.delay > 0 ? this.playTimeout = setTimeout(() => {
      this.player.playFromBeginning();
    }, this.delay) : this.player.playFromBeginning());
  }
  resetPlayDelayTimer() {
    this.playTimeout && (clearTimeout(this.playTimeout), this.playTimeout = null);
  }
  get delay() {
    const e2 = this.element.hasAttribute("delay") ? +(this.element.getAttribute("delay") || 0) : 0;
    return Math.max(e2, 0);
  }
};
var S = class {
  constructor(e2, t2, i2) {
    __publicField(this, "player");
    __publicField(this, "element");
    __publicField(this, "targetElement");
    this.player = e2, this.element = t2, this.targetElement = i2, this.onMouseEnter = this.onMouseEnter.bind(this), this.onMouseLeave = this.onMouseLeave.bind(this);
  }
  onConnected() {
    this.targetElement.addEventListener("mouseenter", this.onMouseEnter), this.targetElement.addEventListener("mouseleave", this.onMouseLeave);
  }
  onDisconnected() {
    this.targetElement.removeEventListener("mouseenter", this.onMouseEnter), this.targetElement.removeEventListener("mouseleave", this.onMouseLeave), this.player.direction = 1;
  }
  onMouseEnter() {
    this.player.direction = 1, this.player.play();
  }
  onMouseLeave() {
    this.player.direction = -1, this.player.play();
  }
};
var R = /^\d*(\.\d+)?$/;
var $ = { attributes: true, childList: false, subtree: false };
var q = class {
  constructor(e2, t2, i2) {
    __publicField(this, "player");
    __publicField(this, "element");
    __publicField(this, "targetElement");
    __publicField(this, "sequenceIndex", 0);
    __publicField(this, "frameState", null);
    __publicField(this, "frameDelayFirst", null);
    __publicField(this, "frameDelayLast", null);
    __publicField(this, "timer");
    __publicField(this, "observer");
    this.player = e2, this.element = t2, this.targetElement = i2, this.observer = new MutationObserver((e3, t3) => {
      for (const t4 of e3)
        "attributes" === t4.type && "sequence" === t4.attributeName && (this.reset(), this.step());
    });
  }
  onReady() {
    this.step();
  }
  onComplete() {
    this.timer = setTimeout(() => {
      this.timer = null, this.frameDelayLast = null, this.step();
    }, this.frameDelayLast || 0);
  }
  onConnected() {
    this.observer.observe(this.element, $);
  }
  onDisconnected() {
    this.observer.disconnect(), this.timer && (clearTimeout(this.timer), this.timer = null);
  }
  reset() {
    this.player.pause(), this.sequenceIndex = 0, this.frameState = this.frameDelayFirst = this.frameDelayLast = null, this.timer && (clearTimeout(this.timer), this.timer = null);
  }
  takeStep() {
    const e2 = this.sequence.split(","), t2 = e2[this.sequenceIndex];
    this.sequenceIndex++, this.sequenceIndex >= e2.length && (this.sequenceIndex = 0);
    const [i2, ...s2] = t2.split(":");
    return { action: i2, params: s2 };
  }
  handleStep(e2, t2) {
    if ("play" === e2) {
      this.frameState && (this.player.state = this.frameState, this.frameState = null);
      t2.includes("reverse") ? (this.player.goToLastFrame(), this.player.direction = -1) : (this.player.goToFirstFrame(), this.player.direction = 1), this.timer = setTimeout(() => {
        this.timer = null, this.frameDelayFirst = null, this.player.play();
      }, this.frameDelayFirst || 0);
    } else if ("frame" === e2) {
      let e3 = 0;
      t2.length && t2[0].match(R) && (e3 = Math.max(0, Math.min(this.player.frames, +t2[0]))), this.player.frame = e3, this.timer = setTimeout(() => {
        this.timer = null, this.frameDelayFirst = null, this.step();
      }, this.frameDelayFirst || 0);
    } else if ("state" === e2)
      this.frameState = t2[0], this.step();
    else if ("delay" === e2) {
      let e3 = null;
      for (const i2 of t2)
        i2 && i2.match(R) && (e3 = +i2);
      e3 && e3 > 0 && (t2.includes("first") && t2.includes("last") ? (this.frameDelayFirst = e3, this.frameDelayLast = e3) : t2.includes("first") ? this.frameDelayFirst = e3 : t2.includes("last") ? this.frameDelayLast = e3 : this.frameDelayFirst = e3), this.step();
    } else if ("idle" !== e2)
      throw new Error(`Invalid sequence action: ${e2}`);
  }
  step() {
    const { action: e2, params: t2 } = this.takeStep();
    e2 && this.handleStep(e2, t2);
  }
  get sequence() {
    return this.element.getAttribute("sequence") || "";
  }
};
function O(e2) {
  I.setPlayerFactory((t2, i2, s2) => new L(e2, t2, i2, s2)), I.defineTrigger("in", F), I.defineTrigger("click", T), I.defineTrigger("hover", A), I.defineTrigger("loop", x), I.defineTrigger("loop-on-hover", M), I.defineTrigger("morph", S), I.defineTrigger("boomerang", D), I.defineTrigger("sequence", q), I.defineTrigger("morph-two-way", D), customElements.get && customElements.get("lord-icon") || customElements.define("lord-icon", I);
}
export {
  D as Boomerang,
  T as Click,
  I as Element,
  A as Hover,
  F as In,
  x as Loop,
  M as LoopOnHover,
  S as Morph,
  L as Player,
  q as Sequence,
  O as defineElement
};
//# sourceMappingURL=@lordicon_element.js.map
